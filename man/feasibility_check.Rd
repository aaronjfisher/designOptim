% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feasibility_check.R
\name{feasibility_check}
\alias{feasibility_check}
\alias{min_n_feasible}
\alias{max_power_feasible}
\title{Check feasibility of power constraints}
\usage{
feasibility_check(FWER, p1, trial_method, r1 = 0.5, r2 = 1 - r1, n_total,
  cases, npoints_sqrt = 10, trial_args = list())

min_n_feasible(min_n = 100, max_n = min_n * 10, step_n = 5,
  showiter = FALSE, trial_method, ...)

max_power_feasible(n_total, cases, p1, trial_method, step_multiplier = 0.01,
  showiter = FALSE, FWER = 0.025, npoints_sqrt = 10, ...)
}
\arguments{
\item{FWER}{the required familywise Type I error rate for the trial}

\item{p1}{population proportion in subpopulation 1}

\item{trial_method}{the type of trial to run. 'cov' for covariance based, 'MB' for Maurer Bretz, and 'covMB' for a combination approach.}

\item{r1}{probability of being randomized to treatment in subpopulation 1}

\item{r2}{probability of being randomized to treatment in subpopulation 2}

\item{n_total}{the total sample size for the 1-stage trial}

\item{cases}{a list of power constraints, of the same format as those passed to \code{\link{optimizeTrial}}}

\item{npoints_sqrt}{\code{feasibility_check} determines feasibility by searching over a grid of points for the alpha to be allocated between the two trials. Determines the number of grid points to search over. The search will be conducted over a triangle of points, with \code{(npoints_sqrt^2)/2} points.}

\item{trial_args}{either an empty list (for trial_method=='cov'), or a list containing graph edges for alpha reallocation (for trial_method=='MB').}

\item{min_n}{smallest sample size to consider for a 1-stage trial}

\item{max_n}{largest sample size to consider}

\item{step_n}{the step size for sample size. For example, if \code{step=20} then we will search in increments of 20 people.}

\item{showiter}{passed to \code{\link[gtools]{binsearch}}, determines whether to show progress.}

\item{...}{passed to \code{feasibility_check}}

\item{step_multiplier}{the step size}
}
\value{
\code{feasibility_check} returns a named vector, with the first element being 1 if the trial is feasible, and zero otherwise. The remaining elements of this vector tell the alpha allocated to each hypothesis in one particular setup that results in a feasible trial. \cr \code{min_n_feasible} returns the smallest sample size that meets the power constraints and FWER specified, as well as the output from \code{feasibility_check} at that sample size. \cr \code{max_power_feasible} returns the multiplier \eqn{m} and a list of modified cases in which each power threshold has been multiplied by \eqn{m}.
}
\description{
Functions to check feasibility of a design, adjust the design in order to make it feasible, or adjust the constraints so that they can be achieved. Here, "feasibility" means that there exists a 1-stage design at the supplied sample size that meets the supplied power and Type I error constraints.
}
\details{
\code{feasibility_check} checks whether it is possible to meet a set of power constraints while maintaining a given familywise Type I error rate (FWER) and total sample size.

\code{min_n_feasible} implements a binary search to find the smallest sample size that meets the power constraints and FWER specified. In each iteration of the search, \code{min_n_feasible} calls \code{feasibility_check}.

Given a sample size and set of power cases, \code{max_power_feasible} finds the number \eqn{m} between 0 and 1 such that if all of the minimum power thresholds are multiplied by \eqn{m}, then these power constraints will be satisfied at the supplied value of \code{n_total}. In other words, it finds the factor by which the power constraints must be relaxed.
}
