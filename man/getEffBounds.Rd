% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/buildTrial.R
\name{getEffBounds}
\alias{getEffBounds}
\title{Compute efficacy boundaries for an adaptive trial}
\usage{
getEffBounds(p1, r1, r2, var_s1_trt, var_s1_con, var_s2_trt, var_s2_con,
  time_limit = 90, num_stages, n_total, n_per_stage, FWER,
  H01_eff_allocated = NULL, H02_eff_allocated = NULL,
  H0C_eff_allocated = NULL, FWER_allocation_matrix = NULL,
  delta_eff = NULL, H01_eff_total_allocated = NULL,
  H02_eff_total_allocated = NULL, H0C_eff_total_allocated = NULL, abseps,
  maxpts, errtol, ...)
}
\arguments{
\item{p1}{proportion of population in subpopulation 1.}

\item{r1}{probability of being randomized to treatment in subpopulation 1}

\item{r2}{probability of being randomized to treatment in subpopulation 2}

\item{var_s1_trt}{variance of the outcome under treament in subpopluation 1.}

\item{var_s1_con}{variance of the outcome under control in subpopluation 1.}

\item{var_s2_trt}{variance of the outcome under treament in subpopluation 2.}

\item{var_s2_con}{variance of the outcome under control in subpopluation 2.}

\item{time_limit}{time limit for calculations}

\item{num_stages}{number of stages for the trial}

\item{n_total}{the total, maximum number of patients to recruit by the end of the study. If entered, n_per_stage will be scaled to have this sum.}

\item{n_per_stage}{a vector with length equal to \code{num_stages}, telling the number of patient's outcomes to be observed in each stage. When there is no delay, this is equal to the number of patients enrolled per stage. When there is delay, this vector is not equal to the number of patients enrolled per stage.}

\item{FWER}{Familywise Type I error rate for the trial.}

\item{H01_eff_allocated}{a vector of length \code{num_stages} telling the proportion of Type I error to allocate to hypothesis \eqn{H01} at each stage of the trial.}

\item{H02_eff_allocated}{a vector of length \code{num_stages} telling the proportion of Type I error to allocate to hypothesis \eqn{H02} at each stage of the trial.}

\item{H0C_eff_allocated}{a vector of length \code{num_stages} telling the proportion of Type I error to allocate to hypothesis \eqn{H0C} at each stage of the trial.}

\item{FWER_allocation_matrix}{a matrix telling the proportion of Type I error to allocation to each hypothesis at each stage. If entered, this will override \code{H01_eff_allocated}, \code{H02_eff_allocated}, and \code{H0C_eff_allocated}.}

\item{delta_eff}{This determines the allocation of Type I error across stages if \code{H01_eff_total_allocated}, \code{H02_eff_total_allocated} and \code{H0C_eff_total_allocated} are set by the user. See the source code.}

\item{H01_eff_total_allocated}{rather than setting the error allocated to each stage, the user can instead set the total error allocated to each hypothesis. \code{H01_eff_total_allocated}, \code{H02_eff_total_allocated}, and \code{H0C_eff_total_allocated} respectively tell the total Type I error to be allocated to \eqn{H01}, \eqn{H02}, and \eqn{H0C}. If set by the user, this will override the \code{H01_eff_allocated} vector.}

\item{H02_eff_total_allocated}{see \code{H01_eff_total_allocated}.}

\item{H0C_eff_total_allocated}{see \code{H01_eff_total_allocated}.}

\item{abseps}{passed to pmvnorm in determining precision of calculations.}

\item{maxpts}{passed to pmvnorm in determining precision of calculations.}

\item{errtol}{determines precision of calculation of z-score boundary.}

\item{...}{needed so that function ignores unused arguments when called by \code{\link{buildTrial}}}
}
\value{
a list of efficacy boundaries for the z-statistics corresponding to each null hypothesis.
}
\description{
Let \eqn{H01}, \eqn{H02} and \eqn{H0C} respectively denote the null hypotheses that there is no treatment effect in subpopulation 1, subpopulation 2 and the combined population.
}
\examples{
\dontrun{

# Fully allocate the error for each stage
K <- 5
getEffBounds(p1 = 0.33,
	 r1 = 1/2,
	 r2 = 1/2,
	 var_s1_trt = 0.375*(1-0.375),
	 var_s1_con = 0.25*(1-0.25),
	 var_s2_trt = 0.325*(1-0.325),
	 var_s2_con = 0.2*(1-0.2),
	 num_stages = 5,
	 n_total = NULL,
	 n_per_stage = rep(200,K),
	 FWER = 0.025,

	 H01_eff_allocated=rep(0.025/(3*K),K),
	 H02_eff_allocated=rep(0.025/(3*K),K),
	 H0C_eff_allocated=rep(0.025/(3*K),K)
	 )
# Use boundaries similar to O'Brien Flemming, with a parametric
# form that specifies the Type I error spent at each stage
# (note the changes in specifying the last four arguments)
getEffBounds(p1 = 0.33,
	 r1 = 1/2,
	 r2 = 1/2,
	 var_s1_trt = 0.375*(1-0.375),
	 var_s1_con = 0.25*(1-0.25),
	 var_s2_trt = 0.325*(1-0.325),
	 var_s2_con = 0.2*(1-0.2),
	 num_stages = 5,
	 n_total = NULL,
	 n_per_stage = rep(200,K),
	 FWER = 0.025,

	 delta_eff = .5, 
	 H01_eff_total_allocated = 0.025/3,
	 H02_eff_total_allocated = 0.025/3,
	 H0C_eff_total_allocated = 0.025/3
	)


}
}
